#!/usr/bin/env python
# coding: utf-8

#This file reduces the size of API-Call Graphs via GVAE.


import pickle
import numpy as np
from torch_geometric.data import Data, DataLoader
from torch_geometric.utils import train_test_split_edges
import torch
import torch_geometric.transforms as T
from torch_geometric.nn import GCNConv
from torch_geometric.utils import train_test_split_edges
from torch_geometric.nn import VGAE
cpu = torch.device('cpu')

 
[dataset, Labels]=pickle.load(open("data_sul_100.p","rb"))


def get_graphs (data):
    for x in data:
        yield x




class VariationalGCNEncoder(torch.nn.Module):
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.conv1 = GCNConv(in_channels, 2 * out_channels)
        self.conv_mu = GCNConv(2 * out_channels, out_channels)
        self.conv_logstd = GCNConv(2 * out_channels, out_channels)

    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index).relu()
        return self.conv_mu(x, edge_index), self.conv_logstd(x, edge_index)

    
gae=list()
for t in get_graphs(dataset):
    print (t)

    data=train_test_split_edges(t)
    # parameters
    out_channels = 50
    num_features = data.features.size()[1]
    epochs = 250

    # model
    model = VGAE(VariationalGCNEncoder(num_features, out_channels))

    # move to GPU (if available)
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = model.to(device)
    x = data.features.to(device)
    train_pos_edge_index = data.train_pos_edge_index.to(device)

    # inizialize the optimizer
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)

    def train():
        model.train()
        optimizer.zero_grad()
        z = model.encode(x, train_pos_edge_index)
        loss = model.recon_loss(z, train_pos_edge_index)
        #if args.variational:
        #   loss = loss + (1 / data.num_nodes) * model.kl_loss()
        loss.backward()
        optimizer.step()

        return float(loss)


    def test(pos_edge_index, neg_edge_index):
        model.eval()
        with torch.no_grad():
            z = model.encode(x, train_pos_edge_index)
        return model.test(z, pos_edge_index, neg_edge_index)


    for epoch in range(1, epochs + 1):
        loss = train()
        torch.cuda.empty_cache()

        auc, ap = test(data.test_pos_edge_index, data.test_neg_edge_index)
        #print('Epoch: {:03d}, AUC: {:.4f}, AP: {:.4f}'.format(epoch, auc, ap))
    print ("graph reduced")
    gae.append(model.encode(x, train_pos_edge_index).to(cpu).detach().numpy())



pickle.dump([gae, Labels], open("data_gae_50.p", "wb" ) )

